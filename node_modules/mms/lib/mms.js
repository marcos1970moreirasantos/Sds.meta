// Generated by CoffeeScript 1.8.0
(function() {
  var Promise, coffee, colors, config, dir, e, ext, fs, mkdirp, mms, path, pkg, rcPath, schema, schemas, template, util, _error, _exec, _info, _loadTasks;

  require('coffee-script/register');

  coffee = require('coffee-script');

  fs = require('fs');

  path = require('path');

  util = require('util');

  mkdirp = require('mkdirp');

  colors = require('colors');

  Promise = require('bluebird');

  Promise.promisifyAll(fs);

  config = require('./config');

  pkg = require('../package.json');

  global.mongo = require('./mongo');


  /**
   * Read the global runtime-config file, overwrite the default configuration
   */

  try {
    rcPath = path.join(process.env.HOME, '.mmsrc.json');
    config = util._extend(config, require(rcPath));
  } catch (_error) {
    e = _error;
  }

  ext = config.ext, dir = config.dir;

  try {
    schema = require(path.resolve(config.schema));
  } catch (_error) {
    e = _error;
    schema = {};
  }

  schema.schemas || (schema.schemas = {});

  schema.config || (schema.config = {});

  config = util._extend(config, schema.config);

  schemas = schema.schemas;


  /**
   * Set the env variable by config file
   * The config object is nested with an env key
   * config = {env: {NODE_ENV: 'development'}}
   */

  Object.keys(config.env || {}).forEach(function(ek) {
    var _base;
    return (_base = process.env)[ek] || (_base[ek] = config.env[ek]);
  });


  /**
   * Migrate template in Coffeescript/Javascript format
   * @type {String}
   */

  template = "exports.up = (next) ->\n  next()\n\nexports.down = (next) ->\n  next()";


  /**
   * Compile the migrate template to Javascript file when use the Javascript pattern
   * @type {[type]}
   */

  if (config.ext === '.js') {
    template = coffee.compile(template, {
      bare: true
    });
  }


  /**
   * output infomation
   * @param  {String} action
   * @param  {String} msg
   * @return {Null}
   */

  _info = function(action, msg) {
    if (msg == null) {
      msg = '';
    }
    return console.log(("  " + action).cyan, msg.grey);
  };


  /**
   * output error message
   * @param  {Error} error object
   * @return {Null}
   */

  _error = function(err) {
    console.error("  fail".red, ("" + err).grey);
    return err;
  };

  _loadTasks = function(direction) {
    if (direction == null) {
      direction = 'up';
    }
    return fs.readdirAsync(config.dir).then(function(files) {
      return files.filter(function(file) {
        if (file.match(/^[0-9]{13}\-.*\.(js|coffee)$/)) {
          return true;
        } else {
          return false;
        }
      }).sort(function(x, y) {
        x = Number(x.split('-')[0]);
        y = Number(y.split('-')[0]);
        if (direction === 'up') {
          return x - y;
        } else {
          return y - x;
        }
      }).map(function(file) {
        return {
          name: file.split('.')[0],
          path: path.resolve(path.join(config.dir, file))
        };
      });
    });
  };

  _exec = function(fn) {
    var _fn;
    if (fn.length === 0) {
      _fn = function(next) {
        return next(null, fn());
      };
    } else {
      _fn = fn;
    }
    return Promise.promisify(_fn)();
  };

  mms = module.exports;

  mms.version = pkg.version;

  mms.create = function(name) {
    var file, timestamp;
    timestamp = Date.now();
    file = path.join(config.dir, "" + timestamp + "-" + name + ext);
    return Promise.promisify(mkdirp)(dir).then(function(dir) {
      return fs.writeFileAsync(file, template);
    }).then(function() {
      return _info('create', file);
    })["catch"](_error);
  };

  mms.migrate = function(name) {
    var stop;
    stop = false;
    return _loadTasks('up').reduce(function(num, task, idx) {
      var migration;
      if (stop) {
        return;
      }
      migration = require(task.path);
      if (typeof migration.up !== 'function') {
        throw new Error('INVALID MIGRATION: ' + task.name);
      }
      if (schemas[task.name]) {
        _info('skip', task.name);
        return num;
      }
      return _exec(migration.up).then(function() {
        schemas[task.name] = {
          status: 'up'
        };
        return fs.writeFileAsync(config.schema, JSON.stringify(schema));
      }).then(function() {
        var _ref;
        if ((_ref = "" + name) != null ? _ref.match(/^[0-9]{1,2}$/) : void 0) {
          if (num === parseInt(name)) {
            stop = true;
          }
        } else if (task.name.indexOf(name) > -1) {
          stop = true;
        }
        _info('up', task.name);
        return num += 1;
      })["catch"](function(err) {
        console.error("  error".red, ("" + err).grey);
        if (typeof migration.down !== 'function') {
          err = new Error("migration " + task.name + " do not have a rollback function!");
          throw err;
        }
        return _exec(migration.down).then(function() {
          console.log("  rollback".yellow, ("" + task.name).grey);
          throw err;
        });
      });
    }, 1).then(function() {
      return _info('complete');
    })["catch"](_error);
  };

  mms.rollback = function(name) {
    var stop;
    name || (name = 1);
    stop = false;
    return _loadTasks('down').reduce(function(num, task, idx) {
      var migration, _ref;
      if (stop) {
        return;
      }
      migration = require(task.path);
      if (typeof migration.down !== 'function') {
        throw new Error('INVALID MIGRATION: ' + task.name);
      }
      if (((_ref = schemas[task.name]) != null ? _ref.status : void 0) !== 'up') {
        return _info('skip', task.name);
      }
      return _exec(migration.down).then(function() {
        delete schemas[task.name];
        return fs.writeFileAsync(config.schema, JSON.stringify(schema));
      }).then(function() {
        var _ref1;
        if ((_ref1 = "" + name) != null ? _ref1.match(/^[0-9]{1,2}$/) : void 0) {
          if (num === parseInt(name)) {
            stop = true;
          }
        } else if (task.name.indexOf(name) > -1) {
          stop = true;
        }
        _info('down', task.name);
        return num += 1;
      });
    }, 1).then(function() {
      return _info('complete');
    })["catch"](_error);
  };

  mms.status = function() {
    return _loadTasks().then(function(tasks) {
      return tasks.forEach(function(task) {
        var name;
        name = task.name;
        if (schemas[name]) {
          return console.log("  up".cyan, name.grey);
        } else {
          return console.log("  down".red, name.grey);
        }
      });
    })["catch"](_error);
  };

}).call(this);
